<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encryption and Decryption Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'bold', serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin: 30px 0;
            font-size: 2.5em;
        }

        h2 {
            color: #34495e;
            margin: 40px 0 20px 0;
            font-size: 1.8em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h3 {
            color: #2c3e50;
            margin: 30px 0 15px 0;
            font-size: 1.4em;
        }

        h4 {
            color: #555;
            margin: 20px 0 10px 0;
            font-size: 1.2em;
        }

        p {
            margin: 15px 0;
            text-align: justify;
        }

        .demo-section {
            background: white;
            padding: 25px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        textarea {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            min-height: 80px;
        }

        input[type="number"] {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 12px 24px;
            margin: 8px 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 15px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:active {
            transform: scale(0.98);
        }

        .result {
            background-color: #ecf0f1;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid #3498db;
            min-height: 50px;
            font-family: monospace;
            word-wrap: break-word;
        }

        .info-box {
            background-color: #e8f4f8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <h1>ENCRYPTION AND DECRYPTION DEMO</h1>
    
    <p style="text-align: center; margin: 20px 0;">
        <strong>submitted to</strong><br>
        Mr. LIM Seyha<br>
        Mathematic Lecturer, Royal University of Phnom Penh, Phnom Penh<br><br>
        April 22, 2025<br><br>
        <strong>by</strong><br>
        Team: 1. Kong borey 2. Sorn Sreyvy 3. Sok Engchhay 4. Sor sovanchhay 5. Tuch panha 6. Soy Rosa 7. Lor Udomvitou <br>
    </p>

    <p>This demonstration presents applications of number theory, including classical encryption-decryption methods and the RSA algorithm. In this report, I will describe the algorithm I developed and the work I have conducted.</p>

    <h2>I. Classical Cryptography</h2>

    <h3>I.I. Caesar Cipher</h3>
    
    <p>One of the earliest and most well-known forms of cryptography was developed by Emperor Julius Caesar. During times of war, he needed a way to send secret messages to his generals. His solution was simple but effective: shift each letter in the alphabet by three positions. For example, the letter A becomes D, B becomes E, and so on. This technique came to be known as the <em>Caesar Cipher</em>.</p>

    <div class="info-box">
        <p>Emperor Julius Caesar made his messages secret by shifting each letter three positions forward in the alphabet. The algorithm to encrypt a message works like this:</p>
        <ol>
            <li><strong>Assign numbers to each letter:</strong> A → 00, B → 01, C → 02, ... Z → 25</li>
            <li><strong>Convert the plaintext into numbers</strong></li>
            <li><strong>Encrypt the numbers by adding 3 to each</strong></li>
            <li><strong>Take the result modulo 26</strong></li>
            <li><strong>Convert the numbers back to letters</strong></li>
        </ol>
    </div>

    <h4>Caesar Cipher Demo</h4>
    <div class="demo-section">
        <label>Enter your text (Plain text or Cipher text):</label>
        <textarea id="caesarInput"></textarea>
        <button onclick="caesarEncrypt()">Encrypt</button>
        <button onclick="caesarDecrypt()">Decrypt</button>
        <div class="result" id="caesarResult">No Result</div>
    </div>

    <h3>I.II. General Shift Cipher</h3>
    <p>The General Shift Cipher is a more advanced version of the Caesar Cipher. Instead of a fixed shift of three positions, it allows for any integer value as the shift. This means that you can choose any number to shift the letters in the alphabet, making it more versatile and secure.</p>

    <h4>General Shift Cipher Demo</h4>
    <div class="demo-section">
        <label>Enter your text (Plain text or Cipher text):</label>
        <textarea id="shiftInput"></textarea>
        <label>Enter the key (No Need For Brute Force Attack):</label>
        <input type="number" id="shiftKey" value="3">
        <button onclick="shiftEncrypt()">Encrypt</button>
        <button onclick="shiftDecrypt()">Decrypt</button>
        <button onclick="shiftBruteForce()">Brute Force Attack</button>
        <div class="result" id="shiftResult">No Result</div>
    </div>

    <h3>I.III. Affine Cipher</h3>
    <p>The Affine Cipher is a more complex encryption method that combines both a shift and a multiplication operation. It uses two keys: one for the shift and another for the multiplication. The formula for encryption is E(x) = (ax + b) mod 26, where 'a' and 'b' are the keys, and 'x' is the numerical representation of the letter.</p>

    <h4>Affine Cipher Demo</h4>
    <div class="demo-section">
        <label>Enter your text (Plain text or Cipher text):</label>
        <textarea id="affineInput"></textarea>
        <label>Enter the key a:</label>
        <input type="number" id="affineKeyA" value="5">
        <label>Enter the key b:</label>
        <input type="number" id="affineKeyB" value="8">
        <button onclick="affineEncrypt()">Encrypt</button>
        <button onclick="affineDecrypt()">Decrypt</button>
        <button onclick="affineBruteForce()">Brute Force Attack</button>
        <div class="result" id="affineResult">No Result</div>
    </div>

    <h3>I.IV. Transposition Cipher</h3>
    <p>In the fascinating world of cryptography, transposition ciphers stand out as one of the oldest and simplest forms of encryption. Rather than changing the actual letters or symbols (as substitution ciphers do), transposition ciphers rearrange the positions of the characters according to a specific system, creating a ciphertext that hides the original message.</p>

    <h4>Transposition Cipher Demo</h4>
    <div class="demo-section">
        <label>Enter your text (Plain text or Cipher text):</label>
        <textarea id="transInput"></textarea>
        <label>Enter the key:</label>
        <input type="number" id="transKey" value="4">
        <button onclick="transEncrypt()">Encrypt</button>
        <button onclick="transDecrypt()">Decrypt</button>
        <div class="result" id="transResult">No Result</div>
    </div>

    <h2>II. RSA</h2>

    <h3>II.I. RSA Cryptography</h3>
    <p>RSA (Rivest-Shamir-Adleman) is a widely used asymmetric encryption algorithm that relies on the mathematical properties of prime numbers. It was invented in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman. RSA is based on the difficulty of factoring large composite numbers into their prime factors.</p>

    <h4>II.I.I RSA Keygen Demo</h4>
    <div class="demo-section">
        <label>Enter the first prime number p:</label>
        <input type="number" id="rsaP" value="61">
        <label>Enter the second prime number q:</label>
        <input type="number" id="rsaQ" value="53">
        <button onclick="rsaKeygen()">Generate Key</button>
        <div class="result" id="rsaKeygenResult">No Result</div>
    </div>

    <h4>II.I.II RSA Encryption Demo</h4>
    <div class="demo-section">
        <label>Enter your text (Plain text or Cipher text):</label>
        <textarea id="rsaEncInput"></textarea>
        <label>Enter the public key (e):</label>
        <input type="number" id="rsaE" value="17">
        <label>Enter the modulus (n):</label>
        <input type="number" id="rsaN" value="3233">
        <button onclick="rsaEncrypt()">Encrypt</button>
        <div class="result" id="rsaEncResult">No Result</div>
    </div>

    <h4>II.I.III RSA Decryption Demo</h4>
    <div class="demo-section">
        <label>Enter your text (Plain text or Cipher text):</label>
        <textarea id="rsaDecInput"></textarea>
        <label>Enter the private key (d):</label>
        <input type="number" id="rsaD" value="2753">
        <label>Enter the modulus (n):</label>
        <input type="number" id="rsaDecN" value="3233">
        <button onclick="rsaDecrypt()">Decrypt</button>
        <div class="result" id="rsaDecResult">No Result</div>
    </div>

    <h2>III. Miscellaneous</h2>
    <p>Check my repository for codes: <a href="https://chhay999.github.io/ite-year-2-cipher/" target="_blank">https://chhay999.github.io/ite-year-2-cipher/</a></p>

    <script>
        // Caesar Cipher Functions
        function caesarEncrypt() {
            const text = document.getElementById('caesarInput').value.toUpperCase();
            const result = shiftCipher(text, 3);
            document.getElementById('caesarResult').textContent = result;
        }

        function caesarDecrypt() {
            const text = document.getElementById('caesarInput').value.toUpperCase();
            const result = shiftCipher(text, -3);
            document.getElementById('caesarResult').textContent = result;
        }

        // General Shift Cipher Functions
        function shiftCipher(text, key) {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char.match(/[A-Z]/)) {
                    const code = ((char.charCodeAt(0) - 65 + key) % 26 + 26) % 26;
                    result += String.fromCharCode(code + 65);
                } else {
                    result += char;
                }
            }
            return result;
        }

        function shiftEncrypt() {
            const text = document.getElementById('shiftInput').value.toUpperCase();
            const key = parseInt(document.getElementById('shiftKey').value);
            const result = shiftCipher(text, key);
            document.getElementById('shiftResult').textContent = result;
        }

        function shiftDecrypt() {
            const text = document.getElementById('shiftInput').value.toUpperCase();
            const key = parseInt(document.getElementById('shiftKey').value);
            const result = shiftCipher(text, -key);
            document.getElementById('shiftResult').textContent = result;
        }

        function shiftBruteForce() {
            const text = document.getElementById('shiftInput').value.toUpperCase();
            let results = 'Brute Force Results:\n\n';
            for (let k = 0; k < 26; k++) {
                results += `Key ${k}: ${shiftCipher(text, -k)}\n`;
            }
            document.getElementById('shiftResult').textContent = results;
        }

        // Affine Cipher Functions
        function gcd(a, b) {
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function modInverse(a, m) {
            for (let x = 1; x < m; x++) {
                if ((a * x) % m === 1) return x;
            }
            return 1;
        }

        function affineEncrypt() {
            const text = document.getElementById('affineInput').value.toUpperCase();
            const a = parseInt(document.getElementById('affineKeyA').value);
            const b = parseInt(document.getElementById('affineKeyB').value);
            
            if (gcd(a, 26) !== 1) {
                document.getElementById('affineResult').textContent = 'Error: Key a must be coprime with 26';
                return;
            }

            let result = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char.match(/[A-Z]/)) {
                    const x = char.charCodeAt(0) - 65;
                    const encrypted = (a * x + b) % 26;
                    result += String.fromCharCode(encrypted + 65);
                } else {
                    result += char;
                }
            }
            document.getElementById('affineResult').textContent = result;
        }

        function affineDecrypt() {
            const text = document.getElementById('affineInput').value.toUpperCase();
            const a = parseInt(document.getElementById('affineKeyA').value);
            const b = parseInt(document.getElementById('affineKeyB').value);
            
            if (gcd(a, 26) !== 1) {
                document.getElementById('affineResult').textContent = 'Error: Key a must be coprime with 26';
                return;
            }

            const aInv = modInverse(a, 26);
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char.match(/[A-Z]/)) {
                    const y = char.charCodeAt(0) - 65;
                    const decrypted = (aInv * (y - b + 26)) % 26;
                    result += String.fromCharCode(decrypted + 65);
                } else {
                    result += char;
                }
            }
            document.getElementById('affineResult').textContent = result;
        }

        function affineBruteForce() {
            const text = document.getElementById('affineInput').value.toUpperCase();
            const validA = [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25];
            let results = 'Brute Force Results:\n\n';
            
            for (let a of validA) {
                for (let b = 0; b < 26; b++) {
                    const aInv = modInverse(a, 26);
                    let decrypted = '';
                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        if (char.match(/[A-Z]/)) {
                            const y = char.charCodeAt(0) - 65;
                            const dec = (aInv * (y - b + 26)) % 26;
                            decrypted += String.fromCharCode(dec + 65);
                        } else {
                            decrypted += char;
                        }
                    }
                    results += `a=${a}, b=${b}: ${decrypted}\n`;
                }
            }
            document.getElementById('affineResult').textContent = results;
        }

        // Transposition Cipher Functions
        function transEncrypt() {
            const text = document.getElementById('transInput').value.replace(/\s/g, '').toUpperCase();
            const key = parseInt(document.getElementById('transKey').value);
            
            let result = '';
            for (let col = 0; col < key; col++) {
                for (let i = col; i < text.length; i += key) {
                    result += text[i];
                }
            }
            document.getElementById('transResult').textContent = result;
        }

        function transDecrypt() {
            const text = document.getElementById('transInput').value.replace(/\s/g, '').toUpperCase();
            const key = parseInt(document.getElementById('transKey').value);
            
            const numRows = Math.ceil(text.length / key);
            const numFullCols = text.length % key || key;
            
            let grid = Array(numRows).fill().map(() => Array(key).fill(''));
            let idx = 0;
            
            for (let col = 0; col < key; col++) {
                const colLen = col < numFullCols ? numRows : numRows - 1;
                for (let row = 0; row < colLen; row++) {
                    grid[row][col] = text[idx++];
                }
            }
            
            let result = '';
            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < key; col++) {
                    result += grid[row][col];
                }
            }
            document.getElementById('transResult').textContent = result.replace(/\s/g, '');
        }

        // RSA Functions
        function isPrime(n) {
            if (n <= 1) return false;
            if (n <= 3) return true;
            if (n % 2 === 0 || n % 3 === 0) return false;
            for (let i = 5; i * i <= n; i += 6) {
                if (n % i === 0 || n % (i + 2) === 0) return false;
            }
            return true;
        }

        function rsaKeygen() {
            const p = parseInt(document.getElementById('rsaP').value);
            const q = parseInt(document.getElementById('rsaQ').value);
            
            if (!isPrime(p) || !isPrime(q)) {
                document.getElementById('rsaKeygenResult').textContent = 'Error: Both p and q must be prime numbers';
                return;
            }
            
            const n = p * q;
            const phi = (p - 1) * (q - 1);
            
            let e = 2;
            while (e < phi) {
                if (gcd(e, phi) === 1) break;
                e++;
            }
            
            const d = modInverse(e, phi);
            
            const result = `n = ${n}\nφ(n) = ${phi}\nPublic Key (e) = ${e}\nPrivate Key (d) = ${d}`;
            document.getElementById('rsaKeygenResult').textContent = result;
        }

        function modPow(base, exp, mod) {
            let result = 1;
            base = base % mod;
            while (exp > 0) {
                if (exp % 2 === 1) {
                    result = (result * base) % mod;
                }
                exp = Math.floor(exp / 2);
                base = (base * base) % mod;
            }
            return result;
        }

        function rsaEncrypt() {
            const text = document.getElementById('rsaEncInput').value.toUpperCase();
            const e = parseInt(document.getElementById('rsaE').value);
            const n = parseInt(document.getElementById('rsaN').value);
            
            let result = [];
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char.match(/[A-Z]/)) {
                    const m = char.charCodeAt(0) - 65;
                    const c = modPow(m, e, n);
                    result.push(c);
                }
            }
            document.getElementById('rsaEncResult').textContent = result.join(' ');
        }

        function rsaDecrypt() {
            const text = document.getElementById('rsaDecInput').value;
            const d = parseInt(document.getElementById('rsaD').value);
            const n = parseInt(document.getElementById('rsaDecN').value);
            
            const ciphers = text.split(' ').map(x => parseInt(x));
            let result = '';
            
            for (let c of ciphers) {
                if (!isNaN(c)) {
                    const m = modPow(c, d, n);
                    result += String.fromCharCode(m + 65);
                }
            }
            document.getElementById('rsaDecResult').textContent = result;
        }
    </script>
</body>
</html>
